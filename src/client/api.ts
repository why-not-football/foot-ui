/* tslint:disable */
/* eslint-disable */
/**
 * API Title
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Booking
 */
export interface Booking {
    /**
     * 
     * @type {string}
     * @memberof Booking
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Booking
     */
    'startDatetime'?: string;
    /**
     * 
     * @type {number}
     * @memberof Booking
     */
    'endDatetime'?: number;
    /**
     * 
     * @type {BookingOwner}
     * @memberof Booking
     */
    'owner'?: BookingOwner;
    /**
     * 
     * @type {Tournament}
     * @memberof Booking
     */
    'tournament'?: Tournament;
    /**
     * 
     * @type {EnablePaying}
     * @memberof Booking
     */
    'paying'?: EnablePaying;
    /**
     * 
     * @type {EnableBooking}
     * @memberof Booking
     */
    'status'?: EnableBooking;
}


/**
 * 
 * @export
 * @interface BookingOwner
 */
export interface BookingOwner {
    /**
     * 
     * @type {number}
     * @memberof BookingOwner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BookingOwner
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookingOwner
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface CreateBooking
 */
export interface CreateBooking {
    /**
     * 
     * @type {string}
     * @memberof CreateBooking
     */
    'startDatetime'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateBooking
     */
    'endDatetime'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateBooking
     */
    'ownerId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateBooking
     */
    'tournamentId'?: number;
    /**
     * 
     * @type {Stadium}
     * @memberof CreateBooking
     */
    'statidum'?: Stadium;
    /**
     * 
     * @type {EnablePaying}
     * @memberof CreateBooking
     */
    'paying'?: EnablePaying;
}


/**
 * 
 * @export
 * @interface CreatePlayAgainst
 */
export interface CreatePlayAgainst {
    /**
     * 
     * @type {Array<number>}
     * @memberof CreatePlayAgainst
     */
    'teams'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof CreatePlayAgainst
     */
    'datetime'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreatePlayAgainst
     */
    'tournamentId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePlayAgainst
     */
    'stadiumId'?: number;
    /**
     * 
     * @type {EnablePhase}
     * @memberof CreatePlayAgainst
     */
    'phase'?: EnablePhase;
    /**
     * 
     * @type {EnableBooking}
     * @memberof CreatePlayAgainst
     */
    'status'?: EnableBooking;
}


/**
 * 
 * @export
 * @interface CreateTeamRequest
 */
export interface CreateTeamRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateTournament
 */
export interface CreateTournament {
    /**
     * 
     * @type {string}
     * @memberof CreateTournament
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTournament
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTournament
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTournament
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTournament
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface CreateUser
 */
export interface CreateUser {
    /**
     * 
     * @type {number}
     * @memberof CreateUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'phone'?: string;
    /**
     * 
     * @type {EnableRole}
     * @memberof CreateUser
     */
    'role'?: EnableRole;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EnableBooking = {
    CommingSoom: 'COMMING_SOOM',
    Now: 'NOW',
    Terminate: 'TERMINATE',
    Cancelled: 'CANCELLED'
} as const;

export type EnableBooking = typeof EnableBooking[keyof typeof EnableBooking];


/**
 * 
 * @export
 * @enum {string}
 */

export const EnablePaying = {
    Cash: 'CASH'
} as const;

export type EnablePaying = typeof EnablePaying[keyof typeof EnablePaying];


/**
 * 
 * @export
 * @enum {string}
 */

export const EnablePhase = {
    Pool: 'POOL',
    QuarterFinal: 'QUARTER_FINAL',
    SemiFinal: 'SEMI_FINAL',
    Final: 'FINAL'
} as const;

export type EnablePhase = typeof EnablePhase[keyof typeof EnablePhase];


/**
 * 
 * @export
 * @enum {string}
 */

export const EnableRole = {
    Admin: 'ADMIN',
    Simple: 'SIMPLE',
    Visitor: 'VISITOR'
} as const;

export type EnableRole = typeof EnableRole[keyof typeof EnableRole];


/**
 * 
 * @export
 * @interface LoginInfo
 */
export interface LoginInfo {
    /**
     * 
     * @type {string}
     * @memberof LoginInfo
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginInfo
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface PlayAgainst
 */
export interface PlayAgainst {
    /**
     * 
     * @type {number}
     * @memberof PlayAgainst
     */
    'id'?: number;
    /**
     * 
     * @type {Array<Team>}
     * @memberof PlayAgainst
     */
    'teams'?: Array<Team>;
    /**
     * 
     * @type {string}
     * @memberof PlayAgainst
     */
    'datetime'?: string;
    /**
     * 
     * @type {PlayAgainstTournament}
     * @memberof PlayAgainst
     */
    'tournament'?: PlayAgainstTournament;
    /**
     * 
     * @type {EnablePhase}
     * @memberof PlayAgainst
     */
    'phase'?: EnablePhase;
    /**
     * 
     * @type {Stadium}
     * @memberof PlayAgainst
     */
    'statidum'?: Stadium;
    /**
     * 
     * @type {EnableBooking}
     * @memberof PlayAgainst
     */
    'status'?: EnableBooking;
}


/**
 * 
 * @export
 * @interface PlayAgainstTournament
 */
export interface PlayAgainstTournament {
    /**
     * 
     * @type {number}
     * @memberof PlayAgainstTournament
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayAgainstTournament
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Stadium
 */
export interface Stadium {
    /**
     * 
     * @type {number}
     * @memberof Stadium
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Stadium
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Tournament
 */
export interface Tournament {
    /**
     * 
     * @type {number}
     * @memberof Tournament
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Tournament
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tournament
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tournament
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tournament
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tournament
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface TournamentAllOf
 */
export interface TournamentAllOf {
    /**
     * 
     * @type {number}
     * @memberof TournamentAllOf
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone'?: string;
    /**
     * 
     * @type {EnableRole}
     * @memberof User
     */
    'role'?: EnableRole;
}



/**
 * BookingApi - axios parameter creator
 * @export
 */
export const BookingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary command a reservation
         * @param {CreateBooking} [createBooking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBooking: async (createBooking?: CreateBooking, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBooking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all booking
         * @param {number} [ownerId] 
         * @param {number} [tournamentId] 
         * @param {string} [datetime] 
         * @param {number} [stadiumId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBooking: async (ownerId?: number, tournamentId?: number, datetime?: string, stadiumId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }

            if (tournamentId !== undefined) {
                localVarQueryParameter['tournamentId'] = tournamentId;
            }

            if (datetime !== undefined) {
                localVarQueryParameter['datetime'] = datetime;
            }

            if (stadiumId !== undefined) {
                localVarQueryParameter['stadiumId'] = stadiumId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookingApi - functional programming interface
 * @export
 */
export const BookingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary command a reservation
         * @param {CreateBooking} [createBooking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBooking(createBooking?: CreateBooking, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Booking>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBooking(createBooking, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get all booking
         * @param {number} [ownerId] 
         * @param {number} [tournamentId] 
         * @param {string} [datetime] 
         * @param {number} [stadiumId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBooking(ownerId?: number, tournamentId?: number, datetime?: string, stadiumId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Booking>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBooking(ownerId, tournamentId, datetime, stadiumId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BookingApi - factory interface
 * @export
 */
export const BookingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookingApiFp(configuration)
    return {
        /**
         * 
         * @summary command a reservation
         * @param {CreateBooking} [createBooking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBooking(createBooking?: CreateBooking, options?: any): AxiosPromise<Booking> {
            return localVarFp.createBooking(createBooking, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all booking
         * @param {number} [ownerId] 
         * @param {number} [tournamentId] 
         * @param {string} [datetime] 
         * @param {number} [stadiumId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBooking(ownerId?: number, tournamentId?: number, datetime?: string, stadiumId?: number, options?: any): AxiosPromise<Array<Booking>> {
            return localVarFp.getAllBooking(ownerId, tournamentId, datetime, stadiumId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookingApi - object-oriented interface
 * @export
 * @class BookingApi
 * @extends {BaseAPI}
 */
export class BookingApi extends BaseAPI {
    /**
     * 
     * @summary command a reservation
     * @param {CreateBooking} [createBooking] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public createBooking(createBooking?: CreateBooking, options?: AxiosRequestConfig) {
        return BookingApiFp(this.configuration).createBooking(createBooking, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all booking
     * @param {number} [ownerId] 
     * @param {number} [tournamentId] 
     * @param {string} [datetime] 
     * @param {number} [stadiumId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public getAllBooking(ownerId?: number, tournamentId?: number, datetime?: string, stadiumId?: number, options?: AxiosRequestConfig) {
        return BookingApiFp(this.configuration).getAllBooking(ownerId, tournamentId, datetime, stadiumId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * login username by name and password
         * @summary login to the server
         * @param {LoginInfo} loginInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginInfo: LoginInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInfo' is not null or undefined
            assertParamExists('login', 'loginInfo', loginInfo)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get current logged user
         * @summary get current logged user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * login username by name and password
         * @summary login to the server
         * @param {LoginInfo} loginInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginInfo: LoginInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get current logged user
         * @summary get current logged user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoami(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityApiFp(configuration)
    return {
        /**
         * login username by name and password
         * @summary login to the server
         * @param {LoginInfo} loginInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginInfo: LoginInfo, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * get current logged user
         * @summary get current logged user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options?: any): AxiosPromise<User> {
            return localVarFp.whoami(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * login username by name and password
     * @summary login to the server
     * @param {LoginInfo} loginInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public login(loginInfo: LoginInfo, options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).login(loginInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get current logged user
     * @summary get current logged user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public whoami(options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).whoami(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TournamentApi - axios parameter creator
 * @export
 */
export const TournamentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create play against
         * @param {CreatePlayAgainst} createPlayAgainst 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayAgainst: async (createPlayAgainst: CreatePlayAgainst, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPlayAgainst' is not null or undefined
            assertParamExists('createPlayAgainst', 'createPlayAgainst', createPlayAgainst)
            const localVarPath = `/tournament/play`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPlayAgainst, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create team
         * @param {CreateTeamRequest} createTeamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam: async (createTeamRequest: CreateTeamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTeamRequest' is not null or undefined
            assertParamExists('createTeam', 'createTeamRequest', createTeamRequest)
            const localVarPath = `/tournament/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create tournament
         * @param {CreateTournament} createTournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTournament: async (createTournament: CreateTournament, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTournament' is not null or undefined
            assertParamExists('createTournament', 'createTournament', createTournament)
            const localVarPath = `/tournament`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTournament, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all tournament
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTournament: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tournament`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TournamentApi - functional programming interface
 * @export
 */
export const TournamentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TournamentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create play against
         * @param {CreatePlayAgainst} createPlayAgainst 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlayAgainst(createPlayAgainst: CreatePlayAgainst, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayAgainst>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlayAgainst(createPlayAgainst, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create team
         * @param {CreateTeamRequest} createTeamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeam(createTeamRequest: CreateTeamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeam(createTeamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create tournament
         * @param {CreateTournament} createTournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTournament(createTournament: CreateTournament, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tournament>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTournament(createTournament, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get all tournament
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTournament(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tournament>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTournament(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TournamentApi - factory interface
 * @export
 */
export const TournamentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TournamentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create play against
         * @param {CreatePlayAgainst} createPlayAgainst 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayAgainst(createPlayAgainst: CreatePlayAgainst, options?: any): AxiosPromise<PlayAgainst> {
            return localVarFp.createPlayAgainst(createPlayAgainst, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create team
         * @param {CreateTeamRequest} createTeamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(createTeamRequest: CreateTeamRequest, options?: any): AxiosPromise<Team> {
            return localVarFp.createTeam(createTeamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create tournament
         * @param {CreateTournament} createTournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTournament(createTournament: CreateTournament, options?: any): AxiosPromise<Tournament> {
            return localVarFp.createTournament(createTournament, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all tournament
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTournament(options?: any): AxiosPromise<Array<Tournament>> {
            return localVarFp.getAllTournament(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TournamentApi - object-oriented interface
 * @export
 * @class TournamentApi
 * @extends {BaseAPI}
 */
export class TournamentApi extends BaseAPI {
    /**
     * 
     * @summary Create play against
     * @param {CreatePlayAgainst} createPlayAgainst 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public createPlayAgainst(createPlayAgainst: CreatePlayAgainst, options?: AxiosRequestConfig) {
        return TournamentApiFp(this.configuration).createPlayAgainst(createPlayAgainst, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create team
     * @param {CreateTeamRequest} createTeamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public createTeam(createTeamRequest: CreateTeamRequest, options?: AxiosRequestConfig) {
        return TournamentApiFp(this.configuration).createTeam(createTeamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create tournament
     * @param {CreateTournament} createTournament 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public createTournament(createTournament: CreateTournament, options?: AxiosRequestConfig) {
        return TournamentApiFp(this.configuration).createTournament(createTournament, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public getAllTournament(options?: AxiosRequestConfig) {
        return TournamentApiFp(this.configuration).getAllTournament(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create User
         * @summary create User
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUser: CreateUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUser' is not null or undefined
            assertParamExists('createUser', 'createUser', createUser)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get user by id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/user/id/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get user by id
         * @param {number} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername: async (userName: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getUserByUsername', 'userName', userName)
            const localVarPath = `/user/name/{userName}`
                .replace(`{${"userName"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * create User
         * @summary create User
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUser: CreateUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get user by id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get user by id
         * @param {number} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByUsername(userName: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByUsername(userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * create User
         * @summary create User
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUser: CreateUser, options?: any): AxiosPromise<User> {
            return localVarFp.createUser(createUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get user by id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: number, options?: any): AxiosPromise<User> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get user by id
         * @param {number} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(userName: number, options?: any): AxiosPromise<User> {
            return localVarFp.getUserByUsername(userName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * create User
     * @summary create User
     * @param {CreateUser} createUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(createUser: CreateUser, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createUser(createUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get user by id
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(userId: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get user by id
     * @param {number} userName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserByUsername(userName: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserByUsername(userName, options).then((request) => request(this.axios, this.basePath));
    }
}


