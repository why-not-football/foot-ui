/* tslint:disable */
/* eslint-disable */
/**
 * Why not football ?
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Booking
 */
export interface Booking {
    /**
     * 
     * @type {number}
     * @memberof Booking
     */
    '_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Booking
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Booking
     */
    'startDatetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Booking
     */
    'endDatetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Booking
     */
    'owner'?: string;
    /**
     * 
     * @type {number}
     * @memberof Booking
     */
    'phone'?: number;
    /**
     * 
     * @type {EnablePaying}
     * @memberof Booking
     */
    'paying'?: EnablePaying;
    /**
     * 
     * @type {EnableBooking}
     * @memberof Booking
     */
    'status'?: EnableBooking;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EnableBooking = {
    CommingSoom: 'COMMING_SOOM',
    Terminate: 'TERMINATE',
    Cancelled: 'CANCELLED'
} as const;

export type EnableBooking = typeof EnableBooking[keyof typeof EnableBooking];


/**
 * 
 * @export
 * @enum {string}
 */

export const EnablePaying = {
    Cash: 'CASH'
} as const;

export type EnablePaying = typeof EnablePaying[keyof typeof EnablePaying];


/**
 * 
 * @export
 * @enum {string}
 */

export const EnablePhase = {
    Pool: 'POOL',
    QuarterFinal: 'QUARTER_FINAL',
    SemiFinal: 'SEMI_FINAL',
    Final: 'FINAL'
} as const;

export type EnablePhase = typeof EnablePhase[keyof typeof EnablePhase];


/**
 * 
 * @export
 * @enum {string}
 */

export const EnableRole = {
    Admin: 'ADMIN',
    Simple: 'SIMPLE'
} as const;

export type EnableRole = typeof EnableRole[keyof typeof EnableRole];


/**
 * 
 * @export
 * @interface LoginInfo
 */
export interface LoginInfo {
    /**
     * 
     * @type {string}
     * @memberof LoginInfo
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginInfo
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface PlayAgainst
 */
export interface PlayAgainst {
    /**
     * 
     * @type {number}
     * @memberof PlayAgainst
     */
    '_id'?: number;
    /**
     * 
     * @type {Array<Team>}
     * @memberof PlayAgainst
     */
    'teams'?: Array<Team>;
    /**
     * 
     * @type {string}
     * @memberof PlayAgainst
     */
    'startDatetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayAgainst
     */
    'endDatetime'?: string;
    /**
     * 
     * @type {PlayAgainstTournament}
     * @memberof PlayAgainst
     */
    'tournament'?: PlayAgainstTournament;
    /**
     * 
     * @type {EnablePhase}
     * @memberof PlayAgainst
     */
    'phase'?: EnablePhase;
    /**
     * 
     * @type {Stadium}
     * @memberof PlayAgainst
     */
    'stadium'?: Stadium;
    /**
     * 
     * @type {EnableBooking}
     * @memberof PlayAgainst
     */
    'status'?: EnableBooking;
}


/**
 * 
 * @export
 * @interface PlayAgainstTournament
 */
export interface PlayAgainstTournament {
    /**
     * 
     * @type {number}
     * @memberof PlayAgainstTournament
     */
    '_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayAgainstTournament
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Stadium
 */
export interface Stadium {
    /**
     * 
     * @type {number}
     * @memberof Stadium
     */
    '_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Stadium
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    '_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Tournament
 */
export interface Tournament {
    /**
     * 
     * @type {number}
     * @memberof Tournament
     */
    '_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Tournament
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tournament
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tournament
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tournament
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tournament
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    '_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone'?: string;
    /**
     * 
     * @type {EnableRole}
     * @memberof User
     */
    'role'?: EnableRole;
}



/**
 * BookingApi - axios parameter creator
 * @export
 */
export const BookingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary command a reservation
         * @param {Booking} [booking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBooking: async (booking?: Booking, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(booking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all booking
         * @param {number} [ownerId] 
         * @param {number} [tournamentId] 
         * @param {string} [datetime] 
         * @param {number} [stadiumId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBooking: async (ownerId?: number, tournamentId?: number, datetime?: string, stadiumId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }

            if (tournamentId !== undefined) {
                localVarQueryParameter['tournamentId'] = tournamentId;
            }

            if (datetime !== undefined) {
                localVarQueryParameter['datetime'] = datetime;
            }

            if (stadiumId !== undefined) {
                localVarQueryParameter['stadiumId'] = stadiumId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookingApi - functional programming interface
 * @export
 */
export const BookingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary command a reservation
         * @param {Booking} [booking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBooking(booking?: Booking, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Booking>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBooking(booking, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get all booking
         * @param {number} [ownerId] 
         * @param {number} [tournamentId] 
         * @param {string} [datetime] 
         * @param {number} [stadiumId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBooking(ownerId?: number, tournamentId?: number, datetime?: string, stadiumId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Booking>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBooking(ownerId, tournamentId, datetime, stadiumId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BookingApi - factory interface
 * @export
 */
export const BookingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookingApiFp(configuration)
    return {
        /**
         * 
         * @summary command a reservation
         * @param {Booking} [booking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBooking(booking?: Booking, options?: any): AxiosPromise<Booking> {
            return localVarFp.createBooking(booking, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all booking
         * @param {number} [ownerId] 
         * @param {number} [tournamentId] 
         * @param {string} [datetime] 
         * @param {number} [stadiumId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBooking(ownerId?: number, tournamentId?: number, datetime?: string, stadiumId?: number, options?: any): AxiosPromise<Array<Booking>> {
            return localVarFp.getAllBooking(ownerId, tournamentId, datetime, stadiumId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookingApi - object-oriented interface
 * @export
 * @class BookingApi
 * @extends {BaseAPI}
 */
export class BookingApi extends BaseAPI {
    /**
     * 
     * @summary command a reservation
     * @param {Booking} [booking] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public createBooking(booking?: Booking, options?: AxiosRequestConfig) {
        return BookingApiFp(this.configuration).createBooking(booking, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all booking
     * @param {number} [ownerId] 
     * @param {number} [tournamentId] 
     * @param {string} [datetime] 
     * @param {number} [stadiumId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public getAllBooking(ownerId?: number, tournamentId?: number, datetime?: string, stadiumId?: number, options?: AxiosRequestConfig) {
        return BookingApiFp(this.configuration).getAllBooking(ownerId, tournamentId, datetime, stadiumId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * login username by name and password
         * @summary login to the server
         * @param {LoginInfo} loginInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginInfo: LoginInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInfo' is not null or undefined
            assertParamExists('login', 'loginInfo', loginInfo)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get current logged user
         * @summary get current logged user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * login username by name and password
         * @summary login to the server
         * @param {LoginInfo} loginInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginInfo: LoginInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get current logged user
         * @summary get current logged user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoami(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityApiFp(configuration)
    return {
        /**
         * login username by name and password
         * @summary login to the server
         * @param {LoginInfo} loginInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginInfo: LoginInfo, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * get current logged user
         * @summary get current logged user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options?: any): AxiosPromise<User> {
            return localVarFp.whoami(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * login username by name and password
     * @summary login to the server
     * @param {LoginInfo} loginInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public login(loginInfo: LoginInfo, options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).login(loginInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get current logged user
     * @summary get current logged user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public whoami(options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).whoami(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TournamentApi - axios parameter creator
 * @export
 */
export const TournamentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create play against
         * @param {PlayAgainst} playAgainst 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdatePlayAgainst: async (playAgainst: PlayAgainst, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playAgainst' is not null or undefined
            assertParamExists('createOrUpdatePlayAgainst', 'playAgainst', playAgainst)
            const localVarPath = `/tournament/play`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playAgainst, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create team
         * @param {Team} team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateTeam: async (team: Team, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'team' is not null or undefined
            assertParamExists('createOrUpdateTeam', 'team', team)
            const localVarPath = `/tournament/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(team, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create tournament
         * @param {Tournament} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateTournament: async (tournament: Tournament, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tournament' is not null or undefined
            assertParamExists('createOrUpdateTournament', 'tournament', tournament)
            const localVarPath = `/tournament`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tournament, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all tournament
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTournament: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tournament`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all team in one tournament
         * @param {number} idTournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTournamentTeams: async (idTournament: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idTournament' is not null or undefined
            assertParamExists('getAllTournamentTeams', 'idTournament', idTournament)
            const localVarPath = `/tournament/{idTournament}/teams`
                .replace(`{${"idTournament"}}`, encodeURIComponent(String(idTournament)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get tournament match
         * @param {string} [date] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTournamentMatch: async (date?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tournament/play`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TournamentApi - functional programming interface
 * @export
 */
export const TournamentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TournamentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create play against
         * @param {PlayAgainst} playAgainst 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdatePlayAgainst(playAgainst: PlayAgainst, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayAgainst>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdatePlayAgainst(playAgainst, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create team
         * @param {Team} team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateTeam(team: Team, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateTeam(team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create tournament
         * @param {Tournament} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateTournament(tournament: Tournament, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tournament>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateTournament(tournament, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get all tournament
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTournament(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tournament>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTournament(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get all team in one tournament
         * @param {number} idTournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTournamentTeams(idTournament: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTournamentTeams(idTournament, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get tournament match
         * @param {string} [date] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTournamentMatch(date?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayAgainst>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTournamentMatch(date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TournamentApi - factory interface
 * @export
 */
export const TournamentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TournamentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create play against
         * @param {PlayAgainst} playAgainst 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdatePlayAgainst(playAgainst: PlayAgainst, options?: any): AxiosPromise<PlayAgainst> {
            return localVarFp.createOrUpdatePlayAgainst(playAgainst, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create team
         * @param {Team} team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateTeam(team: Team, options?: any): AxiosPromise<Team> {
            return localVarFp.createOrUpdateTeam(team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create tournament
         * @param {Tournament} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateTournament(tournament: Tournament, options?: any): AxiosPromise<Tournament> {
            return localVarFp.createOrUpdateTournament(tournament, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all tournament
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTournament(options?: any): AxiosPromise<Array<Tournament>> {
            return localVarFp.getAllTournament(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all team in one tournament
         * @param {number} idTournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTournamentTeams(idTournament: number, options?: any): AxiosPromise<Array<Team>> {
            return localVarFp.getAllTournamentTeams(idTournament, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get tournament match
         * @param {string} [date] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTournamentMatch(date?: string, options?: any): AxiosPromise<PlayAgainst> {
            return localVarFp.getTournamentMatch(date, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TournamentApi - object-oriented interface
 * @export
 * @class TournamentApi
 * @extends {BaseAPI}
 */
export class TournamentApi extends BaseAPI {
    /**
     * 
     * @summary Create play against
     * @param {PlayAgainst} playAgainst 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public createOrUpdatePlayAgainst(playAgainst: PlayAgainst, options?: AxiosRequestConfig) {
        return TournamentApiFp(this.configuration).createOrUpdatePlayAgainst(playAgainst, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create team
     * @param {Team} team 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public createOrUpdateTeam(team: Team, options?: AxiosRequestConfig) {
        return TournamentApiFp(this.configuration).createOrUpdateTeam(team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create tournament
     * @param {Tournament} tournament 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public createOrUpdateTournament(tournament: Tournament, options?: AxiosRequestConfig) {
        return TournamentApiFp(this.configuration).createOrUpdateTournament(tournament, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all tournament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public getAllTournament(options?: AxiosRequestConfig) {
        return TournamentApiFp(this.configuration).getAllTournament(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all team in one tournament
     * @param {number} idTournament 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public getAllTournamentTeams(idTournament: number, options?: AxiosRequestConfig) {
        return TournamentApiFp(this.configuration).getAllTournamentTeams(idTournament, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get tournament match
     * @param {string} [date] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public getTournamentMatch(date?: string, options?: AxiosRequestConfig) {
        return TournamentApiFp(this.configuration).getTournamentMatch(date, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create User
         * @summary create User
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateUser: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createOrUpdateUser', 'user', user)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get user by id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/user/id/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get user by name
         * @param {number} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername: async (userName: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getUserByUsername', 'userName', userName)
            const localVarPath = `/user/name/{userName}`
                .replace(`{${"userName"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * create User
         * @summary create User
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateUser(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get user by id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get user by name
         * @param {number} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByUsername(userName: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByUsername(userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * create User
         * @summary create User
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateUser(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.createOrUpdateUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get user by id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: number, options?: any): AxiosPromise<User> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get user by name
         * @param {number} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(userName: number, options?: any): AxiosPromise<User> {
            return localVarFp.getUserByUsername(userName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * create User
     * @summary create User
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createOrUpdateUser(user: User, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createOrUpdateUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get user by id
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(userId: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get user by name
     * @param {number} userName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserByUsername(userName: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserByUsername(userName, options).then((request) => request(this.axios, this.basePath));
    }
}


